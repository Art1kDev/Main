<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Tetris — Пажитнов А.Л.</title>
  <style>
    body {
      background: black;
      color: #0f0;
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 10px;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      user-select: none;
    }
    #game {
      white-space: pre;
      line-height: 1.2;
      font-size: 14px;
    }
    .hidden { display: none; }
  </style>
</head>
<body>
  <pre id="intro" class="hidden"></pre>
  <pre id="game" class="hidden"></pre>

  <script>
    const GREEN_TEXT = '#0f0';
    const BRIGHT_GREEN_TEXT = '#4f4';
    const DARK_GREEN_TEXT = '#0a0';
    const RESET_COLOR = '#0f0';

    let audioContext = null;
    let isAudioInitialized = false;

    function initAudio() {
      if (isAudioInitialized) return;
      try {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        isAudioInitialized = true;
      } catch (e) {}
    }

    function playTone(freq, durationMs) {
      if (!isAudioInitialized) initAudio();
      if (!audioContext || freq === 0) {
        setTimeout(() => {}, durationMs);
        return;
      }

      const sampleRate = audioContext.sampleRate;
      const numSamples = Math.floor(sampleRate * durationMs / 1000);
      if (numSamples === 0) return;

      const buffer = audioContext.createBuffer(1, numSamples, sampleRate);
      const data = buffer.getChannelData(0);

      const amplitude = 0.3;
      for (let i = 0; i < numSamples; i++) {
        const timeSec = i / sampleRate;
        const phase = (timeSec * freq) % 1.0;
        data[i] = phase < 0.5 ? amplitude : -amplitude;
      }

      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(audioContext.destination);
      source.start();
      source.stop(audioContext.currentTime + durationMs / 1000);
    }

    const MS_PER_BEAT = 450;
    const WHOLE_BEAT = MS_PER_BEAT;
    const HALF_BEAT = MS_PER_BEAT / 2;

    const melody = [
      [330, WHOLE_BEAT], [247, HALF_BEAT], [262, HALF_BEAT], [294, WHOLE_BEAT],
      [262, HALF_BEAT], [247, HALF_BEAT], [220, WHOLE_BEAT], [220, HALF_BEAT],
      [262, HALF_BEAT], [330, WHOLE_BEAT], [294, HALF_BEAT], [262, HALF_BEAT],
      [247, WHOLE_BEAT], [247, HALF_BEAT], [262, HALF_BEAT], [294, WHOLE_BEAT],
      [330, WHOLE_BEAT], [262, WHOLE_BEAT], [220, WHOLE_BEAT], [220, WHOLE_BEAT],
      [null, 400 * 0.9],
      [294, WHOLE_BEAT], [349, HALF_BEAT], [440, HALF_BEAT], [440, HALF_BEAT],
      [392, HALF_BEAT], [349, HALF_BEAT], [330, WHOLE_BEAT], [262, WHOLE_BEAT],
      [330, WHOLE_BEAT], [294, HALF_BEAT], [262, HALF_BEAT], [247, WHOLE_BEAT],
      [247, HALF_BEAT], [262, HALF_BEAT], [294, WHOLE_BEAT], [330, WHOLE_BEAT],
      [262, WHOLE_BEAT], [220, WHOLE_BEAT], [220, WHOLE_BEAT]
    ];

    let musicIndex = 0;
    let isMusicPlaying = false;

    function playMusicLoop() {
      if (!isMusicPlaying) return;
      const note = melody[musicIndex];
      if (note[0] === null) {
        setTimeout(() => {
          musicIndex = (musicIndex + 1) % melody.length;
          playMusicLoop();
        }, note[1]);
      } else {
        playTone(note[0], note[1]);
        setTimeout(() => {
          musicIndex = (musicIndex + 1) % melody.length;
          playMusicLoop();
        }, note[1]);
      }
    }

    const WIDTH = 12;
    const HEIGHT = 20;

    const TETROMINOES = {
      'I': [[1, 1, 1, 1]],
      'O': [[1, 1], [1, 1]],
      'T': [[0, 1, 0], [1, 1, 1]],
      'S': [[0, 1, 1], [1, 1, 0]],
      'Z': [[1, 1, 0], [0, 1, 1]],
      'J': [[1, 0, 0], [1, 1, 1]],
      'L': [[0, 0, 1], [1, 1, 1]]
    };

    const FIELD_CELL_OCCUPIED = '[]';
    const FIELD_CELL_ACTIVE = '[]';
    const FIELD_CELL_EMPTY = ' .';

    function createBoard() {
      return Array(HEIGHT).fill().map(() => Array(WIDTH).fill(0));
    }

    function newPiece() {
      const keys = Object.keys(TETROMINOES);
      const shapeKey = keys[Math.floor(Math.random() * keys.length)];
      const piece = TETROMINOES[shapeKey];
      const x = Math.floor(WIDTH / 2 - piece[0].length / 2);
      const y = 0;
      return { piece, shapeKey, x, y };
    }

    function checkCollision(board, piece, x, y) {
      for (let py = 0; py < piece.length; py++) {
        for (let px = 0; px < piece[py].length; px++) {
          if (piece[py][px]) {
            const boardX = x + px;
            const boardY = y + py;
            if (boardX < 0 || boardX >= WIDTH || boardY >= HEIGHT || (boardY >= 0 && board[boardY][boardX] !== 0)) {
              return true;
            }
          }
        }
      }
      return false;
    }

    function lockPiece(board, piece, x, y) {
      for (let py = 0; py < piece.length; py++) {
        for (let px = 0; px < piece[py].length; px++) {
          if (piece[py][px]) {
            if (y + py >= 0) board[y + py][x + px] = 1;
          }
        }
      }
      return board;
    }

    function clearLines(board) {
      const newBoard = board.filter(row => row.some(cell => cell === 0));
      const linesCleared = HEIGHT - newBoard.length;
      const score = (linesCleared * 100) * linesCleared;
      while (newBoard.length < HEIGHT) {
        newBoard.unshift(Array(WIDTH).fill(0));
      }
      return { board: newBoard, score, linesCleared };
    }

    function rotatePiece(piece) {
      const rows = piece.length;
      const cols = piece[0].length;
      const newPiece = Array(cols).fill().map(() => Array(rows).fill(0));
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          newPiece[x][rows - 1 - y] = piece[y][x];
        }
      }
      return newPiece;
    }

    function drawBoard(board, piece, x, y, score, totalLinesCleared) {
      const level = Math.floor(totalLinesCleared / 10) + 1;
      const tempBoard = board.map(row => [...row]);

      for (let py = 0; py < piece.length; py++) {
        for (let px = 0; px < piece[py].length; px++) {
          if (piece[py][px]) {
            const boardY = y + py;
            const boardX = x + px;
            if (boardY >= 0 && boardY < HEIGHT && boardX >= 0 && boardX < WIDTH) {
              tempBoard[boardY][boardX] = 2;
            }
          }
        }
      }

      const leftPanel = [
        `ПОЛНЫХ СТРОК: ${totalLinesCleared}`,
        `УРОВЕНЬ: ${level}`,
        `СЧЕТ: ${score}`
      ];

      const rightPanel = [
        "7: НАЛЕВО 9: НАПРАВО",
        "8: ПОВОРОТ",
        "",
        "4: УСКОРИТЬ 5: СБРОСИТЬ",
        "1: ПОКАЗАТЬ СЛЕДУЮЩУЮ",
        "0: СТЕРЕТЬ ЭТОТ ТЕКСТ",
        "ПРОБЕЛ - СБРОСИТЬ",
        "",
        "--- (Управление) ---",
        "A / Лево : Влево",
        "D / Право: Вправо",
        "W / Вверх: Поворот",
        "S / Вниз : Сброс (Мягкий)",
        "Пробел   : Сброс (Жесткий)",
        "Q        : Выход"
      ];

      const panelWidth = 25;
      let output = [];

      for (let i = 0; i < HEIGHT; i++) {
        const leftText = i < leftPanel.length ? leftPanel[i] : "";
        const rightText = i < rightPanel.length ? rightPanel[i] : "";
        let boardLine = "   <!";

        for (let cell of tempBoard[i]) {
          if (cell === 1) boardLine += FIELD_CELL_OCCUPIED;
          else if (cell === 2) boardLine += FIELD_CELL_ACTIVE;
          else boardLine += FIELD_CELL_EMPTY;
        }
        boardLine += "!>";
        output.push(`${leftText.padEnd(panelWidth)}${boardLine}${rightText}`);
      }

      const bottomBorderLen = FIELD_CELL_EMPTY.length * WIDTH + 1;
      const bottomBorder1 = "   <!" + "=".repeat(bottomBorderLen) + "!>";
      const bottomBorder2 = "     " + "\\/\\/".repeat(Math.floor(WIDTH / 2)) + (WIDTH % 2 ? "\\/" : "");

      output.push(" ".repeat(panelWidth) + bottomBorder1);
      output.push(" ".repeat(panelWidth) + bottomBorder2);

      document.getElementById('game').textContent = output.join('\n');
    }

    let lastKey = null;
    document.addEventListener('keydown', (e) => {
      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', ' ', 'w', 'a', 's', 'd', 'q', 'W', 'A', 'S', 'D', 'Q'].includes(e.key)) {
        lastKey = e.key.toLowerCase();
        e.preventDefault();
      }
    });

    function getInputValid() {
      const key = lastKey;
      lastKey = null;
      if (key === ' ') return 'drop';
      if (key === 'arrowup' || key === 'w') return 'up';
      if (key === 'arrowleft' || key === 'a') return 'left';
      if (key === 'arrowright' || key === 'd') return 'right';
      if (key === 'arrowdown' || key === 's') return 'down';
      if (key === 'q') return 'quit';
      return null;
    }

    function showIntroScreen() {
      const introEl = document.getElementById('intro');
      const gameEl = document.getElementById('game');
      introEl.classList.remove('hidden');
      gameEl.classList.add('hidden');

      const originalTetrisArt = [
        "    ########  ########  ########  ######:    ######    :####:",
        "    ########  ########  ########  #######    ######   :######",
        "       ##      ##          ##      ##   :##    ##      ##:  :#",
        "       ##      ##          ##      ##    ##    ##      ##     ",
        "       ##      ##          ##      ##   :##    ##      ###:   ",
        "       ##      #######     ##      #######:    ##      :#####:",
        "       ##      #######     ##      ######      ##       .#####:",
        "       ##      ##          ##      ##   ##.    ##         :###",
        "       ##      ##          ##      ##    ##    ##           ##",
        "       ##      ##          ##      ##   :##    ##    #:.  :##",
        "       ##      ########    ##      ##    ##: ######   #######:",
        "       ##      ########    ##      ##    ### ######   .#####:"
      ];

      const pazhitnovText = "ИГРА ОТ ПАЖИТНОВА А.Л.";
      const dateText = "6 ИЮНЯ 1984";
      const fadeSteps = 30;

      let step = 0;
      const interval = setInterval(() => {
        if (step >= fadeSteps) {
          clearInterval(interval);
          introEl.classList.add('hidden');
          return;
        }

        let currentArt = [];
        for (let line of originalTetrisArt) {
          let chars = line.split('');
          const hashCount = (line.match(/#/g) || []).length;
          const toFade = Math.floor(hashCount * (step / fadeSteps));
          let faded = 0;
          for (let i = 0; i < chars.length && faded < toFade; i++) {
            if (chars[i] === '#') {
              chars[i] = ' ';
              faded++;
            }
          }
          currentArt.push(chars.join(''));
        }

        let color = GREEN_TEXT;
        if (step > fadeSteps * 2 / 3) color = DARK_GREEN_TEXT;
        else if (step > fadeSteps / 3) color = BRIGHT_GREEN_TEXT;

        introEl.innerHTML = currentArt.map(line => `<span style="color:${color}">${line}</span>`).join('<br>') +
          `<br><span style="color:${color}">${pazhitnovText}</span><br>` +
          `<span style="color:${color}">${dateText}</span>`;

        step++;
      }, 50);
    }

    function fadeInBoard(board, piece, x, y, score, totalLinesCleared) {
      const totalCells = WIDTH * HEIGHT;
      const duration = 1000;
      const startTime = Date.now();
      const gameEl = document.getElementById('game');
      gameEl.classList.remove('hidden');

      const interval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(1, elapsed / duration);
        const targetCells = Math.floor(totalCells * progress);

        const currentBoard = createBoard();
        let filled = 0;
        for (let r = 0; r < HEIGHT && filled < targetCells; r++) {
          for (let c = 0; c < WIDTH && filled < targetCells; c++) {
            currentBoard[r][c] = 1;
            filled++;
          }
        }

        drawBoard(currentBoard, piece, x, y, score, totalLinesCleared);
        if (elapsed >= duration) {
          clearInterval(interval);
        }
      }, 10);
    }

    let gameRunning = false;
    let board, current, next, score, totalLinesCleared, fallTime, lastTime, gameLoopId;

    function main() {
      showIntroScreen();
      setTimeout(() => {
        isMusicPlaying = true;
        playMusicLoop();

        board = createBoard();
        current = newPiece();
        next = newPiece();
        score = 0;
        totalLinesCleared = 0;
        fallTime = 0;
        lastTime = Date.now();
        gameRunning = true;

        fadeInBoard(board, current.piece, current.x, current.y, score, totalLinesCleared);
        setTimeout(() => {
          gameLoop();
        }, 1100);
      }, 1800);
    }

    function gameLoop() {
      if (!gameRunning) return;

      const now = Date.now();
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;
      fallTime += deltaTime;

      const level = Math.floor(totalLinesCleared / 10) + 1;
      let baseFallSpeed = Math.max(0.1, 0.5 - (level - 1) * 0.04);
      let currentFallSpeed = baseFallSpeed;

      const key = getInputValid();
      if (key === 'quit') {
        endGame();
        return;
      }

      if (key === 'left') {
        if (!checkCollision(board, current.piece, current.x - 1, current.y)) {
          current.x -= 1;
        }
      } else if (key === 'right') {
        if (!checkCollision(board, current.piece, current.x + 1, current.y)) {
          current.x += 1;
        }
      } else if (key === 'up') {
        const rotated = rotatePiece(current.piece);
        if (!checkCollision(board, rotated, current.x, current.y)) {
          current.piece = rotated;
        } else if (!checkCollision(board, rotated, current.x + 1, current.y)) {
          current.piece = rotated;
          current.x += 1;
        } else if (!checkCollision(board, rotated, current.x - 1, current.y)) {
          current.piece = rotated;
          current.x -= 1;
        }
      } else if (key === 'drop') {
        while (!checkCollision(board, current.piece, current.x, current.y + 1)) {
          current.y += 1;
        }
        fallTime = baseFallSpeed;
      }

      if (key === 'down') {
        currentFallSpeed = 0.05;
      }

      if (fallTime >= currentFallSpeed) {
        fallTime = 0;
        if (!checkCollision(board, current.piece, current.x, current.y + 1)) {
          current.y += 1;
        } else {
          board = lockPiece(board, current.piece, current.x, current.y);
          const result = clearLines(board);
          board = result.board;
          score += result.score;
          totalLinesCleared += result.linesCleared;

          current = next;
          current.x = Math.floor(WIDTH / 2 - current.piece[0].length / 2);
          current.y = 0;
          next = newPiece();

          if (checkCollision(board, current.piece, current.x, current.y)) {
            endGame();
            return;
          }
        }
      }

      drawBoard(board, current.piece, current.x, current.y, score, totalLinesCleared);
      gameLoopId = requestAnimationFrame(gameLoop);
    }

    function endGame() {
      gameRunning = false;
      isMusicPlaying = false;
      if (gameLoopId) cancelAnimationFrame(gameLoopId);
      drawBoard(board, current.piece, current.x, current.y, score, totalLinesCleared);
      alert(`Игра Окончена!\nИтоговый Счет: ${score}\nВсего Линий: ${totalLinesCleared}`);
    }

    window.addEventListener('load', () => {
      main();
    });
  </script>
</body>
</html>